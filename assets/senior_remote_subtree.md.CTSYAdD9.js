import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.B1Kupp1q.js";const g=JSON.parse('{"title":"推送指定文件夹","description":"","frontmatter":{"aside":false},"headers":[],"relativePath":"senior/remote/subtree.md","filePath":"senior/remote/subtree.md"}'),p={name:"senior/remote/subtree.md"};function h(n,s,k,l,r,F){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="推送指定文件夹" tabindex="-1">推送指定文件夹 <a class="header-anchor" href="#推送指定文件夹" aria-label="Permalink to &quot;推送指定文件夹&quot;">​</a></h1><p>假如某个 git 项目有三个平行的目录 <code>p1/</code>、<code>p2/</code>、<code>p3/</code>。随着开发进程的推移，发现这三个目录的代码或文件的关联度很低，实际上是各自独立的。这是可以使用 p1proj、p2proj、p3proj 这三个分支来进行管理（关于分支的概念请查看<a href="./../branch/">分支管理</a>），而原来的 master 分支继续保留。</p><p><code>git subtree</code> 就适合这种通过分支来管理文件的情况：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> subtree</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prefix</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p1proj</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> subtree</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prefix</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p2proj</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> subtree</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prefix</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> p3proj</span></span></code></pre></div><p>最常见的场景是写 VitePress 文档，通常文档的位置在项目的 <code>docs/.vitepress/dist</code> 目录中，并且文档部署的地方是 GitHub 中的 gh-pages 分支。</p><p>那么可以执行下面命令，将 dist 目录推送到 gh-pages 分支：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> subtree</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prefix</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docs/.vitepress/dist</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gh-pages</span></span></code></pre></div><p>此时，项目有 master 分支和 gh-pages 分支，并且 gh-pages 分支使用的是 master 分支中的部分文件，所以当修改了 master 中的文档并提交之后，再推送一下 gh-pages 分支，两边代码就能保持一致了。</p>`,8)]))}const o=i(p,[["render",h]]);export{g as __pageData,o as default};
