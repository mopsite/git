import{_ as e,c as a,o as i,ag as o}from"./chunks/framework.B1Kupp1q.js";const l=JSON.parse('{"title":"标签管理","description":"","frontmatter":{"aside":false},"headers":[],"relativePath":"senior/tag/index.md","filePath":"senior/tag/index.md"}'),p={name:"senior/tag/index.md"};function r(n,t,s,_,c,m){return i(),a("div",null,t[0]||(t[0]=[o('<h1 id="标签管理" tabindex="-1">标签管理 <a class="header-anchor" href="#标签管理" aria-label="Permalink to &quot;标签管理&quot;">​</a></h1><p>发布一个版本时，我们通常现在版本库打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git 的标签虽然是版本库的快照，但使其它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git 有 commit，为什么还要引入 tag？</p><p>“请把上周一的那个版本打包发布，commit 号是 6a5819e...”</p><p>“一串烂七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是 v1.2”</p><p>“好的，按照 tag v1.2 查找 commit 就行！”</p><p>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p>',10)]))}const f=e(p,[["render",r]]);export{l as __pageData,f as default};
